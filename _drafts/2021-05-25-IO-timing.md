---
layout: post
title: Why You Should Use a PLL When Dealing with External IOs
date:  2021-05-23 00:00:00 -1000
categories:
---

* TOC
{:toc}

![TUSB1210 Block Diagram](/assets/io_timings/tusb1210_block_diagram.png)


I'll be using a register read as an example, but everything discussed here applied to all ULPI transactions.

The ULPI specification has contains the following figure to illustrate a ULPI register read transactions:

![ULPI Register Read Specification](/assets/io_timings/ulpi_register_read_specification.png)

There are 5 steps:

1. The link (the USB controller) issues a RegRead command on the data bus. It does this by setting the
   bits [7:6] of the data bus to 2'b11, and assigning the address to bits [5:0].
1. The PHY sees the RegRead command, and assets `nxt` to inform the link.
1. The PHY asserts `dir` to turn around the direction of the data bus and take control of it.
1. The PHY drives the value of the desired register to the bus.
1. The PHY deasserts `dir` return control of the data bus to the link.

The specification is not explicit about whether or not the PHY can assert the `nxt` during step 1.
All it says, in section 3.8.3.1, is the following:

> For a register read, as shown in Figure 22, the Link sends a register read command and waits
> for **nxt** to assert.

However, one could reasonable expect a PHY to assert `nxt` *at the earliest* during the next cycle. If not, 
you'd end up with pretty impressive critical path: 

databus output FF of the link -> databus output IO path of the FPGA -> data bus input IO path of the PHY 
-> a combinatorial path inside the PHY -> `nxt` output IO path of PHY -> `nxt` input IO path of the link
-> FF inside the link.
 
That's just not going to happen at 60 MHz!

Here's a conceptual diagram that shows how the IO signals between the Link and PHY are wired up:

![Overall Setup Without Added Delays](/assets/io_timings/io_timings-overall_setup_no_delays.svg)

Things of note:

* The PHY creates the clock and sends it to the link. This is called ULPI *Output Clock* mode.
  Most PHYs also support *Input Clock* mode, where the link sends a clock to the PHY, but the
  Arrow DECA board on which I'm running this is configured in output clock mode.
* Output signal of a chip, whether it's the link or the PHY, are driven by a flip-flop
  right before going to the IO pad.
* Input signals, on the other hand, typically need to go through some combinatorial cloud
  of logic before they hit a register.
* The `ulpi_dir` signal coming from the PHY directly controls the output enable of the 
  ulpi_data IO pad: when `ulpi_dir` is high, the link stops driving `ulpi_data`.

I wrote a testbench that implements the ULPI PHY with the diagram above in mind, and ran a simulation.
The signal behavior matches the one of the ULPI specification:

![ULPI Register Read Simulation](/assets/io_timings/ulpi_register_read_simulation_correct.png)

However, once loaded into the FPGA, things didn't go that way:

![ULPI Register Read SignalTap Wrong](/assets/io_timings/ulpi_register_read_signaltap_wrong.png)

What we see here is that `ulpi_nxt` gets asserted during the first cycle during which 0xC1 is being  
driven by the link.

Looking a bit closer, you can see that I'm reading the register at address 0x01 (remember: the
lower 6 bits of 0xC1 indicate the address.) According to the ULPI specification, this register 
contains the MSB of the vendor ID of the PHY. The Arrow DECA board has a Texas Instruments 
[TUSB1210](https://www.ti.com/product/TUSB1210) PHY with a vendor ID of 0x0451. The PHY should return 0x04, 
but it's returning 0x51!

What is going on here?

The obvious first reaction is it that there's a problem with the chip. Everything is simulating fine,
how could I possibly be the problem! I was 
[not the only one with this reaction](https://community.intel.com/t5/Intel-Quartus-Prime-Software/Strange-code-behavior-once-it-works-once-not/m-p/253916/highlight/true?profile.language=ja):

> Maybe I have a clue - I could not communicate with tusb1210 as it is written in ULPI standard. To write to tusb1210 register, 
> I had to make some hacks (i.e. register usb_stupid_test in `top/ULPI.v`), what is ridiculous, but after this hack it finally 
> started to work (for few days...).

But this is a chip that has been in production for years, and there are only 2 minor erratas. When
dealing with a bug in your C code, one should never first assume that the issue is with the compiler.
The same is through for issues like this.

When real world doesn't match simulation, chances are that there is a timing issue.

The first step is to check the IO timing requirements in the specification:

![ULPI Specification Timing Diagram](/assets/io_timings/ulpi_io_timing_specification.png)

*I edited the diagram to remove 4-bit mode, because most ULPI PHYs don't support that.*

The PHY is in "Output clock" mode. All the timings above are relative to the clock on the 
PHY IO pin.

It'd be a very conventional diagram but the setup time is weird, it is
indicates a max value. That doesn't make a lot of sense: setup time are supposed
to be a minimum value. This turns out to be a bug in the specification: the TUSB1210
datasheet correctly lists it as a minimum value:

![TUSB1210 Timing Specification](/assets/io_timings/tusb1210_timing_specification.png)

The timing parameters above translate into the following Quartus timing constraints:

```tcl
#**************************************************************
# Set Input Delay
#**************************************************************
set_input_delay -max -clock [get_clocks {ulpi_clk}] 9 [get_ports {ulpi_data[*]}]
set_input_delay -max -clock [get_clocks {ulpi_clk}] 9 [get_ports {ulpi_direction}]
set_input_delay -max -clock [get_clocks {ulpi_clk}] 9 [get_ports {ulpi_nxt}]

set_input_delay -min -clock [get_clocks {ulpi_clk}] 0 [get_ports {ulpi_data[*]}]
set_input_delay -min -clock [get_clocks {ulpi_clk}] 0 [get_ports {ulpi_direction}]
set_input_delay -min -clock [get_clocks {ulpi_clk}] 0 [get_ports {ulpi_nxt}]


#**************************************************************
# Set Output Delay
#**************************************************************
set_output_delay -clock [get_clocks {ulpi_clk}] 6 [get_ports {ulpi_data[*]}]
set_output_delay -clock [get_clocks {ulpi_clk}] 6 [get_ports {ulpi_stp}]
```

The PHY output delay of 9ns becomes an input delay of the the link. Similarly, the
6ns setup time of the PHY becomes an output delay of the link.

Note that I add a `-max` to the 9ns input delay, because that 9ns
is a worst case output delay when coming out of the PHY. The specification
doesn't list a minimum output delay, but it's essential to assign a minimum
input delay, so I assign zero there: that's usually a reasonable value.



# References

* [ULPI Specification](https://www.sparkfun.com/datasheets/Components/SMD/ULPI_v1_1.pdf)
* [Texas Instruments TUSB1210 Product Page](https://www.ti.com/product/TUSB1210)

